# Документ требований: Система динамической карты 5000×5000

## Введение

Система динамической карты - это расширение для Zero Ground, которое заменяет текущую систему генерации карты 500×500 единиц на масштабируемую архитектуру на основе ячеек размером 5000×5000 пикселей. Новая система использует детерминированную генерацию стен по формуле, динамическую камеру, следующую за игроком, и оптимизированный рендеринг только видимых областей. Архитектура остаётся в рамках двух файлов (Zero_Ground.cpp и Zero_Ground_client.cpp) без дополнительных зависимостей.

## Глоссарий

- **Ячейка (Cell)**: Квадратная область размером 30×30 пикселей, содержащая информацию о стенах на четырёх сторонах
- **Сетка (Grid)**: Двумерный массив ячеек размером 167×167, покрывающий всё игровое поле
- **CELL_SIZE**: Константа размера ячейки (30.0f пикселей), рассчитанная как PLAYER_SIZE + MAX_WALL_WIDTH + 2*MARGIN
- **Видимая область**: Прямоугольная область вокруг игрока, содержащая ячейки в радиусе ~10 ячеек (300 пикселей)
- **Динамическая камера**: Система отображения, при которой игрок всегда находится в центре экрана, а карта смещается
- **AABB-коллизия**: Axis-Aligned Bounding Box - метод обнаружения столкновений между прямоугольниками
- **Кэширование ячеек**: Оптимизация, при которой видимые ячейки пересчитываются только при смене текущей ячейки игрока
- **Вероятностная генерация**: Генерация карты с использованием случайных чисел и вероятностей для создания уникальной карты при каждом запуске
- **Стена ячейки**: Линия толщиной 2 пикселя на одной из четырёх сторон ячейки (top, right, bottom, left)цип генерации 

## Requirements

### Требование 1: Архитектура сетки ячеек

**Пользовательская история:** Как разработчик системы, я хочу использовать архитектуру на основе сетки ячеек, чтобы эффективно управлять большим игровым полем 5000×5000 пикселей.

#### Критерии приёмки

1. КОГДА определяются константы системы, ТОГДА система ДОЛЖНА установить размер карты 5000×5000 пикселей
2. КОГДА определяются константы системы, ТОГДА система ДОЛЖНА установить CELL_SIZE равным 30.0f пикселей
3. КОГДА рассчитывается размер сетки, ТОГДА система ДОЛЖНА вычислить количество ячеек как 5000/30 ≈ 167 ячеек на сторону
4. КОГДА создаётся сетка, ТОГДА система ДОЛЖНА создать двумерный массив размером 167×167 ячеек
5. КОГДА определяется структура Cell, ТОГДА система ДОЛЖНА включить четыре булевых поля: topWall, rightWall, bottomWall, leftWall
6. КОГДА инициализируется структура Cell, ТОГДА система ДОЛЖНА установить все поля стен в false по умолчанию
7. КОГДА определяются константы системы, ТОГДА система ДОЛЖНА установить PLAYER_SIZE равным 10.0f пикселей
8. КОГДА определяются константы системы, ТОГДА система ДОЛЖНА установить WALL_WIDTH равным 12.0f пикселей
9. КОГДА определяются константы системы, ТОГДА система ДОЛЖНА установить WALL_LENGTH равным 30.0f пикселей (равно CELL_SIZE)

### Требование 2: Вероятностная генерация карты

**Пользовательская история:** Как оператор сервера, я хочу, чтобы карта генерировалась случайным образом с каждым запуском, чтобы получать уникальный игровой опыт в каждой сессии.

#### Критерии приёмки

1. КОГДА сервер генерирует карту, ТОГДА система ДОЛЖНА итерировать по всем ячейкам сетки от (0,0) до (166,166)
2. КОГДА проверяется ячейка с координатами (i,j), ТОГДА система ДОЛЖНА вычислить условие (i+j)%2==1
3. ЕСЛИ условие (i+j)%2==1 истинно, ТОГДА система ДОЛЖНА сгенерировать случайное число от 0 до 100
4. ЕСЛИ случайное число находится в диапазоне [0, 60), ТОГДА система ДОЛЖНА создать одну стену на случайной границе ячейки
5. ЕСЛИ случайное число находится в диапазоне [60, 85), ТОГДА система ДОЛЖНА создать две стены на случайных границах ячейки
6. ЕСЛИ случайное число находится в диапазоне [85, 100], ТОГДА система НЕ ДОЛЖНА создавать стены для этой ячейки
7. КОГДА создаётся стена, ТОГДА система ДОЛЖНА установить размер стены 12 пикселей в ширину и 30 пикселей в длину
8. КОГДА выбирается граница для стены, ТОГДА система ДОЛЖНА случайно выбрать одну из четырёх сторон (top, right, bottom, left)
9. КОГДА создаются две стены, ТОГДА система ДОЛЖНА выбрать две разные границы ячейки
10. КОГДА генерация завершена, ТОГДА система ДОЛЖНА проверить проходимость карты используя BFS
11. ЕСЛИ путь между точками спавна существует, ТОГДА система ДОЛЖНА принять сгенерированную карту
12. ЕСЛИ путь не существует, ТОГДА система ДОЛЖНА перегенерировать карту с максимумом 10 попыток

### Требование 3: Динамическая камера

**Пользовательская история:** Как игрок, я хочу, чтобы камера следовала за моим персонажем, чтобы я всегда видел окружающую область и мог ориентироваться на большой карте.

#### Критерии приёмки

1. КОГДА обновляется игровой вид, ТОГДА система ДОЛЖНА создать sf::View с размером, равным размеру окна
2. КОГДА устанавливается центр камеры, ТОГДА система ДОЛЖНА установить центр view на текущую позицию игрока
3. КОГДА применяется view к окну, ТОГДА система ДОЛЖНА вызвать window.setView(view) перед отрисовкой
4. КОГДА игрок движется, ТОГДА система ДОЛЖНА автоматически обновлять позицию камеры каждый кадр
5. КОГДА игрок находится в центре экрана, ТОГДА система ДОЛЖНА отображать окружающую область карты вокруг игрока

### Требование 4: Оптимизированный рендеринг видимой области

**Пользовательская история:** Как игрок, я хочу плавный геймплей без падений производительности, чтобы игра оставалась отзывчивой даже на большой карте.

#### Критерии приёмки

1. КОГДА рассчитывается видимая область, ТОГДА система ДОЛЖНА вычислить текущую ячейку игрока как (playerPosition.x / CELL_SIZE, playerPosition.y / CELL_SIZE)
2. КОГДА определяются границы видимости, ТОГДА система ДОЛЖНА установить startX как max(0, playerCellX - 10)
3. КОГДА определяются границы видимости, ТОГДА система ДОЛЖНА установить startY как max(0, playerCellY - 10)
4. КОГДА определяются границы видимости, ТОГДА система ДОЛЖНА установить endX как min(166, playerCellX + 10)
5. КОГДА определяются границы видимости, ТОГДА система ДОЛЖНА установить endY как min(166, playerCellY + 10)
6. КОГДА отрисовываются стены, ТОГДА система ДОЛЖНА итерировать только по ячейкам в диапазоне [startX, endX] × [startY, endY]
7. КОГДА отрисовывается стена ячейки, ТОГДА система ДОЛЖНА создать sf::RectangleShape с соответствующими размерами и позицией
8. КОГДА отрисовывается topWall, ТОГДА система ДОЛЖНА создать прямоугольник размером (30.0f, 12.0f) на позиции границы ячейки
9. КОГДА отрисовывается rightWall, ТОГДА система ДОЛЖНА создать прямоугольник размером (12.0f, 30.0f) на позиции границы ячейки
10. КОГДА отрисовывается bottomWall, ТОГДА система ДОЛЖНА создать прямоугольник размером (30.0f, 12.0f) на позиции границы ячейки
11. КОГДА отрисовывается leftWall, ТОГДА система ДОЛЖНА создать прямоугольник размером (12.0f, 30.0f) на позиции границы ячейки
12. КОГДА подсчитывается количество отрисованных стен, ТОГДА система ДОЛЖНА обеспечить максимум 500 стен в кадре

### Требование 5: Система столкновений на основе ячеек

**Пользовательская история:** Как игрок, я хочу реалистичные столкновения со стенами, чтобы не проходить сквозь препятствия и получать правильную физическую обратную связь.

#### Критерии приёмки

1. КОГДА игрок движется, ТОГДА система ДОЛЖНА вычислить новую позицию как playerPosition + movement * deltaTime
2. КОГДА проверяются столкновения, ТОГДА система ДОЛЖНА создать sf::FloatRect для игрока с размерами (nextPos.x - PLAYER_SIZE/2, nextPos.y - PLAYER_SIZE/2, PLAYER_SIZE, PLAYER_SIZE)
3. КОГДА проверяются столкновения, ТОГДА система ДОЛЖНА итерировать по видимым ячейкам в диапазоне [startX, endX] × [startY, endY]
4. КОГДА проверяется topWall ячейки, ТОГДА система ДОЛЖНА создать sf::FloatRect для стены размером (x, y, 30.0f, 12.0f)
5. КОГДА обнаруживается пересечение, ТОГДА система ДОЛЖНА вызвать playerRect.intersects(wallRect)
6. ЕСЛИ обнаружено столкновение, ТОГДА система ДОЛЖНА оттолкнуть игрока на 1 пиксель в направлении, противоположном движению
7. КОГДА рассчитывается отталкивание, ТОГДА система ДОЛЖНА вычислить вектор направления как (oldPos - newPos)
8. КОГДА применяется отталкивание, ТОГДА система ДОЛЖНА нормализовать вектор направления
9. КОГДА применяется отталкивание, ТОГДА система ДОЛЖНА установить позицию как oldPos + direction * 1.0f
10. ЕСЛИ столкновений не обнаружено, ТОГДА система ДОЛЖНА обновить playerPosition = nextPos
11. КОГДА игрок достигает границ карты (0 или 5000), ТОГДА система ДОЛЖНА ограничить позицию в пределах валидных координат

### Требование 6: Кэширование видимых ячеек

**Пользовательская история:** Как разработчик системы, я хочу оптимизировать расчёты видимости, чтобы минимизировать вычислительную нагрузку при движении игрока внутри одной ячейки.

#### Критерии приёмки

1. КОГДА инициализируется система кэширования, ТОГДА система ДОЛЖНА создать статические переменные lastPlayerCellX и lastPlayerCellY со значением -1
2. КОГДА рассчитывается текущая ячейка игрока, ТОГДА система ДОЛЖНА вычислить playerCellX и playerCellY
3. КОГДА проверяется необходимость обновления, ТОГДА система ДОЛЖНА сравнить playerCellX с lastPlayerCellX
4. КОГДА проверяется необходимость обновления, ТОГДА система ДОЛЖНА сравнить playerCellY с lastPlayerCellY
5. ЕСЛИ playerCellX != lastPlayerCellX ИЛИ playerCellY != lastPlayerCellY, ТОГДА система ДОЛЖНА пересчитать startX, startY, endX, endY
6. КОГДА границы пересчитаны, ТОГДА система ДОЛЖНА обновить lastPlayerCellX = playerCellX
7. КОГДА границы пересчитаны, ТОГДА система ДОЛЖНА обновить lastPlayerCellY = playerCellY
8. ЕСЛИ ячейка игрока не изменилась, ТОГДА система ДОЛЖНА использовать кэшированные значения границ

### Требование 7: Сетевая синхронизация карты

**Пользовательская история:** Как системный архитектор, я хочу эффективно синхронизировать данные карты между сервером и клиентами, чтобы минимизировать сетевой трафик и время загрузки.

#### Критерии приёмки

1. КОГДА клиент подключается к серверу, ТОГДА система ДОЛЖНА сериализовать структуру grid в массив байтов
2. КОГДА отправляются данные карты, ТОГДА система ДОЛЖНА использовать TCP сокет для передачи
3. КОГДА рассчитывается размер данных, ТОГДА система ДОЛЖНА вычислить sizeof(grid) для всей сетки
4. КОГДА клиент получает данные карты, ТОГДА система ДОЛЖНА десериализовать массив байтов обратно в структуру grid
5. КОГДА синхронизируются позиции через UDP, ТОГДА система ДОЛЖНА отправлять только данные игроков в радиусе 25*CELL_SIZE (750 пикселей)
6. КОГДА валидируются полученные позиции, ТОГДА система ДОЛЖНА проверить, что координаты находятся в диапазоне [0, 5000]

### Требование 8: Отладка и мониторинг производительности

**Пользовательская история:** Как разработчик, я хочу видеть метрики производительности рендеринга, чтобы оптимизировать систему и выявлять узкие места.

#### Критерии приёмки

1. КОГДА компилируется debug-версия, ТОГДА система ДОЛЖНА включить вывод отладочной информации
2. КОГДА отрисовывается кадр, ТОГДА система ДОЛЖНА подсчитать количество отрисованных стен
3. КОГДА кадр завершён, ТОГДА система ДОЛЖНА вывести в консоль "Walls rendered: [число]"
4. КОГДА компилируется release-версия, ТОГДА система НЕ ДОЛЖНА выводить отладочную информацию
5. КОГДА мониторится производительность, ТОГДА система ДОЛЖНА отслеживать FPS
6. ЕСЛИ FPS падает ниже 55, ТОГДА система ДОЛЖНА залогировать предупреждение с количеством отрисованных стен

### Требование 9: Интеграция с существующей системой

**Пользовательская история:** Как разработчик, я хочу интегрировать новую систему карты без изменения сетевой логики и UI, чтобы сохранить совместимость с существующим кодом.

#### Критерии приёмки

1. КОГДА интегрируется новая система, ТОГДА система ДОЛЖНА сохранить все существующие TCP/UDP сокеты без изменений
2. КОГДА интегрируется новая система, ТОГДА система ДОЛЖНА сохранить протокол готовности игроков без изменений
3. КОГДА интегрируется новая система, ТОГДА система ДОЛЖНА сохранить UI стартового экрана сервера без изменений
4. КОГДА интегрируется новая система, ТОГДА система ДОЛЖНА сохранить UI экрана подключения клиента без изменений
5. КОГДА интегрируется новая система, ТОГДА система ДОЛЖНА заменить только функции генерации карты, рендеринга и столкновений
6. КОГДА компилируется код, ТОГДА система ДОЛЖНА оставаться в рамках двух файлов: Zero_Ground.cpp и Zero_Ground_client.cpp
7. КОГДА компилируется код, ТОГДА система НЕ ДОЛЖНА создавать дополнительные .h или .cpp файлы
8. КОГДА компилируется код, ТОГДА система НЕ ДОЛЖНА добавлять внешние библиотеки кроме SFML 2.6.1

### Требование 10: Производительность большой карты

**Пользовательская история:** Как игрок, я хочу, чтобы игра работала плавно на карте 5000×5000, чтобы получать комфортный игровой опыт без лагов.

#### Критерии приёмки

1. КОГДА запускается на системе с Intel i3-8100 и 8GB RAM, ТОГДА система ДОЛЖНА поддерживать минимум 55 FPS
2. КОГДА подключены два игрока, ТОГДА система ДОЛЖНА использовать менее 40% CPU
3. КОГДА отрисовывается кадр, ТОГДА система ДОЛЖНА отрисовывать максимум 500 стен
4. КОГДА рассчитываются столкновения, ТОГДА система ДОЛЖНА проверять только видимые ячейки (максимум 21×21 = 441 ячейка)
5. КОГДА обновляется камера, ТОГДА система ДОЛЖНА выполнять обновление за время менее 0.1 миллисекунды
6. КОГДА генерируется карта, ТОГДА система ДОЛЖНА завершить генерацию за время менее 100 миллисекунд
