# План реализации: Система динамической карты 5000×5000

## ВАЖНО: Архитектурные требования
- Весь код сервера находится в одном файле: `Zero_Ground/Zero_Ground.cpp`
- Весь код клиента находится в одном файле: `Zero_Ground_client/Zero_Ground_client.cpp`
- НЕ создавать отдельные .h или дополнительные .cpp файлы
- НЕ добавлять внешние библиотеки (только SFML 2.6.1)
- Все функции и структуры должны быть внутри основных cpp файлов
- Интегрировать новую систему БЕЗ изменения существующей сетевой логики и UI

- [x] 1. Обновление констант и структур данных в серверном коде


  - Открыть файл Zero_Ground/Zero_Ground.cpp
  - Добавить константы: MAP_SIZE=5000.0f, CELL_SIZE=30.0f, GRID_SIZE=167, PLAYER_SIZE=10.0f, WALL_WIDTH=12.0f, WALL_LENGTH=30.0f
  - Определить структуру Cell с четырьмя булевыми полями (topWall, rightWall, bottomWall, leftWall)
  - Создать сетку: std::vector<std::vector<Cell>> grid(GRID_SIZE, std::vector<Cell>(GRID_SIZE))
  - _Требования: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9_

- [ ] 2. Реализация вероятностной генерации карты на сервере
  - Добавить функцию setWall(Cell& cell, int side) для установки стены по номеру стороны (0-3)
  - Реализовать функцию generateMap() с итерацией по всем ячейкам
  - Проверять условие (i+j)%2==1 для каждой ячейки
  - Генерировать случайное число 0-99 для определения вероятности
  - Реализовать логику: 0-59 (60%) - 1 стенка, 60-84 (25%) - 2 стенки, 85-99 (15%) - 0 стенок
  - Для 1 стенки: выбрать случайную сторону (0-3)
  - Для 2 стенок: выбрать две разные случайные стороны
  - Использовать std::random_device и std::mt19937 для генерации случайных чисел
  - _Требования: 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9_

- [ ] 3. Реализация BFS валидации проходимости на сервере
  - Реализовать функцию canMove(sf::Vector2i from, sf::Vector2i to) для проверки возможности перехода между ячейками
  - Проверять стены в зависимости от направления движения (dx, dy)
  - Реализовать функцию isPathExists(sf::Vector2i start, sf::Vector2i end) с алгоритмом BFS
  - Использовать очередь std::queue<sf::Vector2i> и массив visited
  - Проверять 4 направления движения (вверх, вправо, вниз, влево)
  - Возвращать true если путь найден, false если нет
  - _Требования: 2.10, 2.11_

- [ ] 4. Реализация генерации с повторными попытками на сервере
  - Реализовать функцию generateValidMap() с циклом до 10 попыток
  - Очищать сетку перед каждой попыткой
  - Вызывать generateMap() для генерации
  - Проверять проходимость между точками спавна (250, 4750) и (4750, 250)
  - Логировать номер успешной попытки
  - Если все попытки неудачны, вызвать handleMapGenerationFailure()
  - _Требования: 2.12_

- [ ] 5. Реализация обработки ошибок генерации на сервере
  - Реализовать функцию handleMapGenerationFailure()
  - Вывести сообщение об ошибке в std::cerr
  - Показать сообщение об ошибке в окне (опционально)
  - Корректно завершить работу с exit(1)
  - _Требования: 2.12_

- [ ] 6. Реализация динамической камеры на сервере
  - Реализовать функцию updateCamera(sf::RenderWindow& window, sf::Vector2f playerPosition)
  - Создать sf::View с размером окна
  - Установить центр view на позицию игрока
  - Ограничить камеру границами карты (учесть половину размера окна)
  - Применить view к окну через window.setView(view)
  - Вызывать updateCamera() в игровом цикле перед рендерингом
  - _Требования: 3.1, 3.2, 3.3, 3.4, 3.5_

- [ ] 7. Реализация оптимизированного рендеринга на сервере
  - Реализовать функцию renderVisibleWalls(sf::RenderWindow& window, sf::Vector2f playerPosition)
  - Вычислить текущую ячейку игрока: playerCellX = playerPosition.x / CELL_SIZE
  - Добавить статические переменные для кэширования: lastPlayerCellX, lastPlayerCellY, startX, startY, endX, endY
  - Пересчитывать границы только если ячейка игрока изменилась
  - Установить границы: startX = max(0, playerCellX-10), endX = min(166, playerCellX+10)
  - Итерировать по видимым ячейкам [startX, endX] × [startY, endY]
  - Отрисовывать стены с центрированием на границах: position - WALL_WIDTH/2
  - Подсчитывать количество отрисованных стен
  - _Требования: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 8. Добавление debug-вывода количества стен на сервере
  - Добавить #ifdef _DEBUG блок в конце renderVisibleWalls()
  - Выводить "Walls rendered: [число]" в std::cout
  - Убедиться, что вывод работает только в debug-режиме
  - _Требования: 4.12, 8.1, 8.2, 8.3, 8.4_

- [ ] 9. Реализация системы столкновений на сервере
  - Реализовать функцию resolveCollision(sf::Vector2f oldPos, sf::Vector2f newPos)
  - Создать sf::FloatRect для игрока с центром в newPos
  - Вычислить ячейку игрока и границы проверки (playerCellX ± 1)
  - Итерировать по ячейкам в радиусе 3×3 вокруг игрока
  - Проверять каждую стену ячейки с центрированием на границе
  - Использовать playerRect.intersects(wallRect) для обнаружения столкновения
  - При столкновении: вычислить вектор направления (oldPos - newPos)
  - Нормализовать вектор и оттолкнуть на 1 пиксель: oldPos + direction * 1.0f
  - Ограничить позицию границами карты [PLAYER_SIZE/2, MAP_SIZE - PLAYER_SIZE/2]
  - _Требования: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 5.10, 5.11_

- [ ] 10. Интеграция новой системы в игровой цикл сервера
  - Заменить вызов старой функции генерации карты на generateValidMap()
  - Добавить вызов updateCamera() перед рендерингом
  - Заменить вызов старой функции рендеринга на renderVisibleWalls()
  - Заменить вызов старой функции столкновений на resolveCollision()
  - Обновить начальные позиции игроков для карты 5000×5000
  - Убедиться, что сетевая логика и UI остались без изменений
  - _Требования: 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 11. Реализация сетевой синхронизации карты на сервере
  - Реализовать функцию serializeMap(std::vector<char>& buffer)
  - Использовать std::memcpy для копирования grid в buffer
  - Реализовать функцию sendMapToClient(sf::TcpSocket& clientSocket)
  - Отправить размер данных (uint32_t) через TCP
  - Отправить данные карты через TCP
  - Интегрировать sendMapToClient() в обработчик подключения клиента
  - _Требования: 7.1, 7.2, 7.3_

- [ ] 12. Контрольная точка - Проверка работы сервера
  - Скомпилировать серверный код
  - Запустить сервер и проверить генерацию карты
  - Проверить, что карта генерируется успешно (не более 10 попыток)
  - Проверить, что камера следует за игроком
  - Проверить, что отрисовываются только видимые стены
  - Проверить, что столкновения работают корректно
  - Убедиться что всё работает корректно, спросить пользователя при возникновении вопросов

- [ ] 13. Обновление констант и структур данных в клиентском коде
  - Открыть файл Zero_Ground_client/Zero_Ground_client.cpp
  - Добавить те же константы, что и на сервере
  - Определить структуру Cell (идентичную серверной)
  - Создать сетку: std::vector<std::vector<Cell>> grid(GRID_SIZE, std::vector<Cell>(GRID_SIZE))
  - _Требования: 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9_

- [ ] 14. Реализация получения карты от сервера на клиенте
  - Реализовать функцию deserializeMap(const std::vector<char>& buffer)
  - Использовать std::memcpy для копирования buffer в grid
  - Реализовать функцию receiveMapFromServer(sf::TcpSocket& serverSocket)
  - Получить размер данных (uint32_t) через TCP
  - Получить данные карты через TCP
  - Вызвать deserializeMap() для восстановления сетки
  - Интегрировать receiveMapFromServer() в процесс подключения к серверу
  - _Требования: 7.4, 7.5_

- [ ] 15. Реализация динамической камеры на клиенте
  - Скопировать функцию updateCamera() с сервера
  - Вызывать updateCamera() в игровом цикле клиента перед рендерингом
  - Убедиться, что камера следует за локальным игроком (синий круг)
  - _Требования: 3.1, 3.2, 3.3, 3.4, 3.5_

- [ ] 16. Реализация оптимизированного рендеринга на клиенте
  - Скопировать функцию renderVisibleWalls() с сервера
  - Адаптировать для позиции локального игрока клиента
  - Добавить debug-вывод количества стен (#ifdef _DEBUG)
  - Интегрировать с системой тумана войны (применить затемнение к стенам вне радиуса видимости)
  - _Требования: 4.1, 4.2, 4.3, 4.4, 4.5, 4.6, 4.7, 4.8, 4.9, 4.10, 4.11, 4.12, 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8, 8.1, 8.2, 8.3, 8.4_

- [ ] 17. Реализация системы столкновений на клиенте
  - Скопировать функцию resolveCollision() с сервера
  - Интегрировать в обработку движения локального игрока
  - Убедиться, что столкновения работают для синего круга
  - _Требования: 5.1, 5.2, 5.3, 5.4, 5.5, 5.6, 5.7, 5.8, 5.9, 5.10, 5.11_

- [ ] 18. Интеграция новой системы в игровой цикл клиента
  - Добавить вызов updateCamera() перед рендерингом
  - Заменить вызов старой функции рендеринга на renderVisibleWalls()
  - Заменить вызов старой функции столкновений на resolveCollision()
  - Обновить начальную позицию клиента для карты 5000×5000
  - Обновить валидацию позиций для диапазона [0, 5000]
  - Убедиться, что сетевая логика и UI остались без изменений
  - _Требования: 7.6, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6, 9.7, 9.8_

- [ ] 19. Контрольная точка - Проверка работы клиента
  - Скомпилировать клиентский код
  - Запустить сервер и клиент
  - Проверить, что клиент получает карту от сервера
  - Проверить, что карты идентичны на сервере и клиенте
  - Проверить, что камера следует за игроком на клиенте
  - Проверить, что столкновения работают на клиенте
  - Убедиться что всё работает корректно, спросить пользователя при возникновении вопросов

- [ ] 20. Интеграционное тестирование полного цикла
  - Запустить сервер и дождаться успешной генерации карты
  - Подключить клиент к серверу
  - Проверить, что протокол готовности работает
  - Начать игру и проверить синхронизацию позиций
  - Проверить, что оба игрока видят одинаковую карту
  - Проверить, что столкновения работают для обоих игроков
  - Проверить, что туман войны применяется корректно
  - Проверить, что камера следует за каждым игроком на его экране
  - _Требования: 9.1, 9.2, 9.3, 9.4, 9.5_

- [ ] 21. Тестирование производительности
  - Измерить FPS на сервере при движении по карте
  - Измерить FPS на клиенте при движении по карте
  - Проверить, что FPS >= 55 на обоих
  - Измерить использование CPU (должно быть < 40%)
  - Проверить количество отрисовываемых стен (должно быть <= 500)
  - Измерить время генерации карты (должно быть < 100мс)
  - Если производительность недостаточна, оптимизировать код
  - _Требования: 10.1, 10.2, 10.3, 10.4, 10.5, 10.6, 8.5, 8.6_

- [ ] 22. Тестирование вероятностей генерации
  - Сгенерировать 100 карт
  - Подсчитать количество ячеек с 0, 1 и 2 стенками
  - Проверить, что распределение близко к 15%/60%/25%
  - Если распределение сильно отличается, проверить логику генерации
  - _Требования: 2.4, 2.5, 2.6_

- [ ] 23. Тестирование BFS валидации
  - Создать тестовую карту с известным путём
  - Проверить, что isPathExists() возвращает true
  - Создать тестовую карту без пути (полностью заблокированную)
  - Проверить, что isPathExists() возвращает false
  - Проверить, что генератор перегенерирует карту при отсутствии пути
  - _Требования: 2.10, 2.11, 2.12_

- [ ] 24. Тестирование кэширования видимых ячеек
  - Добавить счётчик пересчётов границ видимости
  - Переместить игрока внутри одной ячейки
  - Проверить, что границы не пересчитываются
  - Переместить игрока в соседнюю ячейку
  - Проверить, что границы пересчитываются ровно один раз
  - _Требования: 6.1, 6.2, 6.3, 6.4, 6.5, 6.6, 6.7, 6.8_

- [ ] 25. Финальная проверка и очистка кода
  - Проверить, что весь код находится в двух файлах (Zero_Ground.cpp и Zero_Ground_client.cpp)
  - Проверить, что не созданы дополнительные .h или .cpp файлы
  - Проверить, что не добавлены внешние библиотеки
  - Добавить комментарии к сложным алгоритмам (генерация, BFS, коллизии)
  - Проверить, что debug-вывод работает только в debug-режиме
  - Убедиться, что существующая сетевая логика и UI не изменены
  - _Требования: 9.6, 9.7, 9.8_

- [ ] 26. Документирование изменений
  - Обновить README.md с информацией о новой системе карты
  - Документировать размер карты (5000×5000 пикселей)
  - Документировать систему ячеек (167×167 ячеек по 30 пикселей)
  - Документировать алгоритм генерации (вероятности 60%/25%/15%)
  - Документировать требования к производительности (55+ FPS, <40% CPU)
  - Добавить примеры использования и известные ограничения
